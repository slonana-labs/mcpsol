# Data Model: Minimize Framework Overhead

**Feature**: [spec.md](./spec.md) | **Plan**: [plan.md](./plan.md)

## Overview

This feature modifies code generation, not runtime data structures. The "data model" here describes the structure of generated code and compile-time metadata.

## Generated Code Structures

### 1. Instruction Metadata (Compile-Time)

```rust
/// Compile-time metadata for each instruction
/// Generated by #[mcp_instruction] macro
struct InstructionMeta {
    discriminator: [u8; 8],      // SHA256("global:<name>")[..8]
    expected_len: usize,         // discriminator + sum(arg_sizes)
    arg_offsets: &'static [usize], // [8, 16, 24, ...] pre-computed
    arg_sizes: &'static [usize],   // [8, 8, 1, ...] for types
}
```

### 2. Dispatcher Structure (Generated)

**Current Structure** (slow):
```rust
fn process_instruction(data: &[u8]) -> Result {
    if data.len() < 8 { return Err(...); }
    let disc: [u8; 8] = data[..8].try_into().map_err(|_| ...)?;
    let args = &data[8..];

    match disc {
        [a, b, c, d, e, f, g, h] => {
            let mut offset = 0;
            let arg0 = parse_with_bounds_check(args, &mut offset)?;
            let arg1 = parse_with_bounds_check(args, &mut offset)?;
            handler(arg0, arg1)
        }
    }
}
```

**Optimized Structure** (target):
```rust
fn process_instruction(data: &[u8]) -> Result {
    // Single length check covers everything
    const MIN_LEN: usize = 8;  // Just discriminator for dispatch
    if data.len() < MIN_LEN { return Err(...); }

    // Direct discriminator read
    let disc = unsafe { *(data.as_ptr() as *const [u8; 8]) };

    match disc {
        [a, b, c, d, e, f, g, h] => {
            // Per-instruction length check
            const EXPECTED: usize = 8 + 8 + 8;  // disc + arg0 + arg1
            if data.len() < EXPECTED { return Err(...); }

            // Direct reads at compile-time offsets
            let arg0 = unsafe { read_u64(data, 8) };
            let arg1 = unsafe { read_u64(data, 16) };
            handler(arg0, arg1)
        }
    }
}
```

### 3. Argument Type Mapping

| Rust Type | Size | Read Function |
|-----------|------|---------------|
| `u8` | 1 | `*ptr` |
| `u16` | 2 | `read_unaligned::<u16>` |
| `u32` | 4 | `read_unaligned::<u32>` |
| `u64` | 8 | `read_unaligned::<u64>` |
| `i8` | 1 | `*ptr as i8` |
| `i16` | 2 | `read_unaligned::<i16>` |
| `i32` | 4 | `read_unaligned::<i32>` |
| `i64` | 8 | `read_unaligned::<i64>` |
| `bool` | 1 | `*ptr != 0` |
| `Pubkey` | 32 | `read_unaligned::<[u8; 32]>` |
| `[u8; N]` | N | `read_unaligned::<[u8; N]>` |

### 4. Helper Functions (SDK)

```rust
// sdk/src/read.rs - Zero-cost read helpers

/// Read u64 at offset. SAFETY: caller must ensure offset + 8 <= data.len()
#[inline(always)]
pub unsafe fn read_u64_unchecked(data: &[u8], offset: usize) -> u64 {
    core::ptr::read_unaligned(data.as_ptr().add(offset) as *const u64)
}

/// Read u32 at offset. SAFETY: caller must ensure offset + 4 <= data.len()
#[inline(always)]
pub unsafe fn read_u32_unchecked(data: &[u8], offset: usize) -> u32 {
    core::ptr::read_unaligned(data.as_ptr().add(offset) as *const u32)
}

// ... etc for all types
```

### 5. Context Variants

**Full Context** (when `context = true`):
```rust
pub struct Context<'info, T: Accounts<'info>> {
    pub program_id: &'info Pubkey,
    pub accounts: T,
    pub remaining_accounts: &'info [AccountInfo<'info>],
}
```

**Lightweight** (default, no wrapper):
```rust
// No struct - just pass accounts directly
fn handler(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    arg0: u64,
) -> Result<()>
```

## State Transitions

N/A - This feature modifies compile-time code generation. No runtime state transitions.

## Validation Rules

### Generated Code Validation

1. **Length Check Completeness**: Every instruction arm must check `data.len() >= EXPECTED_LEN` before any unsafe read
2. **Offset Correctness**: Compile-time offsets must equal sum of preceding argument sizes + 8 (discriminator)
3. **Type Safety**: Read function must match declared argument type

### Macro Validation

1. **Attribute Parsing**: `#[mcp_instruction]` must correctly parse `context = true/false`
2. **Type Recognition**: All argument types must map to known sizes
3. **Error on Unknown**: Unknown types must produce compile error, not runtime UB

## Relationships

```
#[mcp_program]
    │
    ├── generates → __mcpsol_process_instruction()
    │                   │
    │                   ├── uses → read_u64_unchecked() (sdk)
    │                   ├── uses → read_u32_unchecked() (sdk)
    │                   └── uses → Context<T> (optional)
    │
    └── collects → #[mcp_instruction] metadata
                       │
                       ├── discriminator: [u8; 8]
                       ├── expected_len: usize
                       └── arg_offsets: [usize]
```
